package kafka

import (
	"github.com/confluentinc/confluent-kafka-go/kafka"
	"fmt"
	"os"
	"sync"
	_ "reflect"
	"errors"
)


var (
	kafka_host = os.Getenv("KAFKA_HOST")
	kafka_port = os.Getenv("KAFKA_PORT")
	EventTopics = []string{
		"Pre-Confirmed", 
		"Confirmed", 
		"Rejected", 
		"Canceled", 
		"Delivered",
} // for the love of god, DON'T TOUCH THIS SEQUENCE.
)

// Standard structures for managing Kafka Events.




type KafkaBackend struct {
	// Backend that has permission to create Producers and Consumers, it the certain separated methods for that.
	sync.Mutex
	kafka_host string
	kafka_port string
}


type KafkaProducer struct {
	// Kafka Producer Structure
	topic string 
	producer *kafka.Producer
}


type KafkaConsumer struct {
	// Kafka Consumer Structure
	topic string 
	consumer *kafka.Consumer
}


// Event Data Scructure.
type OrderEventData struct {
	message string // comment message to the Event
	orderId string // order Id to know with what Order this event dealing.
}


// Methods related to Generating Kafka Consumers/Producers for Listening Incoming Order Events...



// Producers Is Getting Generated by that method
func (this *KafkaBackend) createKafkaProducer() (*kafka.Producer, error){

	producer, error := kafka.NewProducer(&kafka.ConfigMap{

		"bootstrap.servers": fmt.Sprintf("%s:%s", kafka_host, kafka_port),
		"sasl.mechanisms": "PLAIN",
	})
	if error != nil {
		panic("Failed to Create Producer.")
	}
	return producer, nil
}


// Consumers getting Generated by that method and starts listen.
func (this *KafkaBackend) createKafkaConsumer() (*kafka.Consumer, error){
	consumer, error := kafka.NewConsumer(&kafka.ConfigMap{
		"bootstrap.servers": fmt.Sprintf("%s:%s", kafka_host, kafka_port),
		"sasl.mechanisms": "PLAIN",
	})
	if error != nil {return nil, error}
	assigned := consumer.SubscribeTopics(EventTopics, nil)
	if assigned != nil {
	panic("Consumer Failed to Assign Partitions and Topics to listen");
	}else {return consumer, nil}
}





// Base Method for producing Kafka events.. All of the other controllers and methods use this `method` for making events.
func (this *KafkaProducer) ProduceEvent(
KafkaEventResponseChannel chan kafka.Event, topic string, message string) (bool, error){

	this.producer.Produce(&kafka.Message{

		TopicPartition: kafka.TopicPartition{Topic: &this.topic, Partition: kafka.PartitionAny},
		Value: []byte(message),
	}, KafkaEventResponseChannel,
	)

  deliveryResponse := <- KafkaEventResponseChannel 

    defer close(KafkaEventResponseChannel) // closing the Kafka Event Response Channel
	if valid, error := deliveryResponse.(kafka.Event); error != true{
	fmt.Sprintf(
	"Invalid Respond from Kafka, Invalid Message Type for %s", valid)
	return false,  errors.New("Invalid Event Type, Message has not been delivered.")
	}else{return true, nil}
}



// There goes the types of the Events that is Possible to send `Accepted` and `Rejected`
// when the front end application rejected the order to be delivered it will send event with one of this topics 
// back to the main store application.



// Method for sending `Accepted` Orders. 

func (this *KafkaProducer) SendAcceptOrderEvent(eventData OrderEventData) (bool, error){
  // sends kafka event. to the `accept` topic
  KafkaEventChannel := make(chan kafka.Event, 10000)

  jsonData := fmt.Sprintf(`{"message":"%s", "orderId": "%s"}`,
  eventData.message, eventData.orderId)

  sended, error := this.ProduceEvent(
  KafkaEventChannel, EventTopics[0], jsonData)

  if sended != true || error != nil {
  return false, errors.New("Failed to Send Kafka Event.")} else{
  return true, nil}
}


// Method for sending `Rejected` Orders.

func (this *KafkaProducer) SendRejectOrderEvent(eventData OrderEventData) (bool, error){
  // sends kafka event to the `reject` topic
  KafkaEventChannel := make(chan kafka.Event, 10000)

  jsonData := fmt.Sprintf(`{"message":"%s", "orderId": "%s"}`, 
  eventData.message, eventData.orderId)

  sended, error := this.ProduceEvent(
  KafkaEventChannel, EventTopics[1], jsonData)

  if sended != true || error != nil {
  return false, errors.New("Failed to Send Kafka Event.")} else{
  return true, nil}
}
