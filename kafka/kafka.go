package kafka

import (
	"errors"
	"fmt"
	"os"
	_ "reflect"
	"sync"
	"log"
	"github.com/confluentinc/confluent-kafka-go/kafka"
	"github.com/LovePelmeni/OrderCheckout/models"
)

var (
	OrderTopic = os.Getenv("ORDER_TOPIC") // topic for listening to..


	kafka_host  = os.Getenv("KAFKA_HOST")
	kafka_port  = os.Getenv("KAFKA_PORT")
	EventTopics = []string{
		"Pre-Confirmed",
		"Confirmed",
		"Rejected",
		"Canceled",
		"Delivered",
	} // for the love of god, DON'T TOUCH THIS SEQUENCE.
)

// loggers goes there 
var (
	ErrorLogger *log.Logger 
	DebugLogger *log.Logger 
	WarningLogger *log.Logger 
	InfoLogger *log.Logger 
)
// Standard structures for managing Kafka Events.


type KafkaBackend struct {
	// Backend that has permission to create Producers and Consumers, it the certain separated methods for that.
	sync.Mutex
	Kafka_host string
	Kafka_port string
}

type KafkaProducer struct {
	Topic string 
	Producer *kafka.Producer
}

type KafkaConsumer struct {
	Topic string 
	Consumer *kafka.Consumer 
}

// Methods related to Generating Kafka Consumers/Producers for Listening Incoming Order Events...

// Producers Is Getting Generated by that method
func (this *KafkaBackend) CreateKafkaProducer() (*kafka.Producer, error) {

	producer, error := kafka.NewProducer(&kafka.ConfigMap{

		"bootstrap.servers": fmt.Sprintf("%s:%s", kafka_host, kafka_port),
		"sasl.mechanisms":   "PLAIN",
	})
	if error != nil {
		panic("Failed to Create Producer.")
	}
	return producer, nil
}

// Consumers getting Generated by that method and starts listen.
func (this *KafkaBackend) CreateKafkaConsumer() (*kafka.Consumer, error) {
	consumer, error := kafka.NewConsumer(&kafka.ConfigMap{
		"bootstrap.servers": fmt.Sprintf("%s:%s", kafka_host, kafka_port),
		"sasl.mechanisms":   "PLAIN",
	})
	if error != nil {
		return nil, error
	}
	assigned := consumer.SubscribeTopics(EventTopics, nil)
	if assigned != nil {
		panic("Consumer Failed to Assign Partitions and Topics to listen")
	} else {
		return consumer, nil
	}
}


// Producer API Methods...



// Base Method for producing Kafka events.. All of the other controllers and methods use this `method` for making events.
func (this *KafkaProducer) ProduceEvent(
	KafkaEventResponseChannel chan kafka.Event, topic string, message string) (bool, error) {

	this.Producer.Produce(&kafka.Message{

		TopicPartition: kafka.TopicPartition{Topic: &this.Topic, Partition: kafka.PartitionAny},
		Value:          []byte(message),
	}, KafkaEventResponseChannel,
	)

	deliveryResponse := <-KafkaEventResponseChannel

	defer close(KafkaEventResponseChannel) // closing the Kafka Event Response Channel
	if valid, error := deliveryResponse.(kafka.Event); error != true {
		ErrorLogger.Println(fmt.Sprintf("Invalid Respond from Kafka, Invalid Message Type for %s", valid))
		return false, errors.New("Invalid Event Type, Message has not been delivered.")
	} else {
		return true, nil
	}
}

// There goes the types of the Events that is Possible to send `Accepted` and `Rejected`
// when the front end application rejected the order to be delivered it will send event with one of this topics
// back to the main store application.

// Method for sending `Accepted` Orders.

func (this *KafkaProducer) SendAcceptOrderEvent(message string, orderId string) (bool, error) {
	// sends kafka event. to the `accept` topic
	KafkaEventChannel := make(chan kafka.Event, 10000)

	jsonData := fmt.Sprintf(`{"message": "%s",
    "status": "accepted", "orderId": "%s"}`, message, orderId)
	sended, error := this.ProduceEvent(
		KafkaEventChannel, EventTopics[0], jsonData)

	if sended != true || error != nil {
		return false, errors.New("Failed to Send Kafka Event.")
	} else {
		return true, nil
	}
}

// Method for sending `Rejected` Orders.

func (this *KafkaProducer) SendRejectOrderEvent(message string, orderId string) (bool, error) {
	// sends kafka event to the `reject` topic
	KafkaEventChannel := make(chan kafka.Event, 10000)

	jsonData := fmt.Sprintf(
	`{"message":"%s", "status": "rejected", "order": "%s"}`, message, orderId)
	sended, error := this.ProduceEvent(
	KafkaEventChannel, EventTopics[1], jsonData)

	if sended != true || error != nil {
		return false, errors.New("Failed to Send Kafka Event.")
	} else {
		return true, nil
	}
}


// Consumer API Methods 





// Methods Process Kafka Received Events related to the Orders and Creates A Order Confirm Request.
func ProcessOrderConsumeEvent(MessageEvent *kafka.Message){


	destinationAddress := models.DestinationAddress{} // prepares DestinationAddress Params
	customerCredentials := models.OrderCustomerCredentials{} // prepares order customer Credentials
	goods := models.Goods{} // Prepares Purchased Products Info.

	order := models.CreateOrder(customerCredentials, destinationAddress, goods)
	DebugLogger.Println(fmt.Sprintf("New Order Request has been obtained..., %s", order.Order_name))
}	



// runs as a goroutine...
// Method for listening to the Order Topic...
func (this *KafkaConsumer) ConsumeKafkaOrderEvents() (bool, error){
	consumerError := this.Consumer.SubscribeTopics([]string{"Order"}, nil)
	if consumerError != nil {return false, errors.New("Failed to Subscribe To Notifications.")
	}
	for {
		message := this.Consumer.Poll(0)
		if validMessageEvent, valid := message.(*kafka.Message); valid == true{
			ProcessOrderConsumeEvent(validMessageEvent)
		}
	}
}

